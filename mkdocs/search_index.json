{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "一. 介绍"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/install/", 
            "text": "", 
            "title": "二. 安装"
        }, 
        {
            "location": "/ovs/", 
            "text": "同宿主，同子网的2台VM互通\n\n\n\n\n# 建立桥接\novs-vsctl add-br br-int\n\n# 用veth模拟vm，将veth在宿主上的一端加入桥接\novs-vsctl add-port br-int poi-vm1\novs-vsctl add-port br-int poi-vm2\n\n\n\n\n同宿主，不同子网之间隔离（分别桥接）\n\n\n\n\n# 建立桥接，biv-100是子网1，biv-200是子网2\novs-vsctl add-br biv-100\novs-vsctl add-br biv-200\n\n# 用veth模拟vm，2个vm在宿主上的一端分别加入2个桥接\novs-vsctl add-port biv-100 poi-vm1\novs-vsctl add-port biv-200 poi-vm2\n\n\n\n\n同宿主，不同子网之间隔离（打tag）\n\n\n\n\n# 建立桥接\novs-vsctl add-br br-int\n\n# 用veth模拟vm，2个vm在宿主上的一端加入桥接，同时打tag\novs-vsctl add-port br-int poi-vm1 -- set port poi-vm1 tag=100\novs-vsctl add-port br-int poi-vm2 -- set port poi-vm2 tag=200\n\n\n\n\n同宿主，不同桥接之间二层互通\n\n\n\n\n# 建立桥接\novs-vsctl add-br biv-100\novs-vsctl add-br biv-200\n\n# 创建patch port，2端分别桥接到biv-100和biv-200\novs-vsctl add-port biv-100 patch-to-200 -- set interface patch-to-200 type=patch -- set interface patch-to-200 options:peer=patch-to-100\novs-vsctl add-port biv-200 patch-to-100 -- set interface patch-to-100 type=patch -- set interface patch-to-100 options:peer=patch-to-200\n\n# 用veth模拟vm，vm在宿主的一端加入桥接\novs-vsctl add-port biv-100 poi-vm1\novs-vsctl add-port biv-200 poi-vm2\n\n\n\n\n不同宿主，同子网互通这么做会环路\n\n\n\n\n\n\n这样看上去好像没啥问题，但是这个图可以画成这样：\n\n\n\n\n这样就形成了一个环路，如果宿主机就2台还不会环路，只要达到3台就会开始环路\n\n\n注意：我们当前用linux bridge没有环路是因为无论是多播vtep还是单播vtep，一个桥接网卡都只桥接一个vtep，而广播包（或者叫泛洪）的特性是数据包从非入口的所有端口泛洪出去，即如果一个linux bridge桥接2个vtep，也是会造成环路的\n\n\n其实openstack的网络架构图画出来看也是有环路的：\n\n\n\n\n那么为什么没有环路呢，是因为如果br-tun只是个简单的switch/hub功能，那么是会环路的，vtep收到数据包后会从br-tun的另一个vtep泛洪出去。但br-tun是openflow控制的，其中2条规则起了关键作用：\n\n\n\n\n\n\nbr-tun从vtep收到数据包后，将vni去掉，加上vlan头，这还不是关键，关键是第2点\n\n\n\n\n\n\n然后将数据包从patch-int端口发出，即这个数据包只发到br-int而不会交到另一个vtep上，因此不会产生环路\n\n\n\n\n\n\niptables/ebtables对ovs port不起作用\n\n\n\n\n经测试，使用iptables和ebtables对ovs端口不起任何作用，只对linux bridge的端口起作用", 
            "title": "三. ovs"
        }, 
        {
            "location": "/ovs/#2vm", 
            "text": "# 建立桥接\novs-vsctl add-br br-int\n\n# 用veth模拟vm，将veth在宿主上的一端加入桥接\novs-vsctl add-port br-int poi-vm1\novs-vsctl add-port br-int poi-vm2", 
            "title": "同宿主，同子网的2台VM互通"
        }, 
        {
            "location": "/ovs/#_1", 
            "text": "# 建立桥接，biv-100是子网1，biv-200是子网2\novs-vsctl add-br biv-100\novs-vsctl add-br biv-200\n\n# 用veth模拟vm，2个vm在宿主上的一端分别加入2个桥接\novs-vsctl add-port biv-100 poi-vm1\novs-vsctl add-port biv-200 poi-vm2", 
            "title": "同宿主，不同子网之间隔离（分别桥接）"
        }, 
        {
            "location": "/ovs/#tag", 
            "text": "# 建立桥接\novs-vsctl add-br br-int\n\n# 用veth模拟vm，2个vm在宿主上的一端加入桥接，同时打tag\novs-vsctl add-port br-int poi-vm1 -- set port poi-vm1 tag=100\novs-vsctl add-port br-int poi-vm2 -- set port poi-vm2 tag=200", 
            "title": "同宿主，不同子网之间隔离（打tag）"
        }, 
        {
            "location": "/ovs/#_2", 
            "text": "# 建立桥接\novs-vsctl add-br biv-100\novs-vsctl add-br biv-200\n\n# 创建patch port，2端分别桥接到biv-100和biv-200\novs-vsctl add-port biv-100 patch-to-200 -- set interface patch-to-200 type=patch -- set interface patch-to-200 options:peer=patch-to-100\novs-vsctl add-port biv-200 patch-to-100 -- set interface patch-to-100 type=patch -- set interface patch-to-100 options:peer=patch-to-200\n\n# 用veth模拟vm，vm在宿主的一端加入桥接\novs-vsctl add-port biv-100 poi-vm1\novs-vsctl add-port biv-200 poi-vm2", 
            "title": "同宿主，不同桥接之间二层互通"
        }, 
        {
            "location": "/ovs/#_3", 
            "text": "这样看上去好像没啥问题，但是这个图可以画成这样：   这样就形成了一个环路，如果宿主机就2台还不会环路，只要达到3台就会开始环路  注意：我们当前用linux bridge没有环路是因为无论是多播vtep还是单播vtep，一个桥接网卡都只桥接一个vtep，而广播包（或者叫泛洪）的特性是数据包从非入口的所有端口泛洪出去，即如果一个linux bridge桥接2个vtep，也是会造成环路的  其实openstack的网络架构图画出来看也是有环路的：   那么为什么没有环路呢，是因为如果br-tun只是个简单的switch/hub功能，那么是会环路的，vtep收到数据包后会从br-tun的另一个vtep泛洪出去。但br-tun是openflow控制的，其中2条规则起了关键作用：    br-tun从vtep收到数据包后，将vni去掉，加上vlan头，这还不是关键，关键是第2点    然后将数据包从patch-int端口发出，即这个数据包只发到br-int而不会交到另一个vtep上，因此不会产生环路", 
            "title": "不同宿主，同子网互通这么做会环路"
        }, 
        {
            "location": "/ovs/#iptablesebtablesovs-port", 
            "text": "经测试，使用iptables和ebtables对ovs端口不起任何作用，只对linux bridge的端口起作用", 
            "title": "iptables/ebtables对ovs port不起作用"
        }, 
        {
            "location": "/openflow/", 
            "text": "查看\n\n\n\n\n# 查看openflow端口信息\novs-ofctl show ovs-switch\n\n# 查看openflow端口编号\novs-vsctl get interface p0 ofport\n\n# 查看datapath\novs-dpctl show\n\n# 查看流表\novs-ofctl dump-flows ovs-switch\n\n\n\n\n流表操作\n\n\n\n\n默认规则\n\n\n每个交换机创建之后默认都有一条流表规则，用于允许所有流量通过\n\n\nNXST_FLOW reply (xid=0x4):\n\n cookie=0x0, duration=1588.919s, table=0, n_packets=50, n_bytes=3260, idle_age=0, priority=0 actions=NORMAL\n\n\n\n\n加亮这条就是默认的流表，如果这条删掉，那么当其他条目都没匹配到的时候，数据包就会被丢弃\n\n\n添加规则\n\n\n# 屏蔽所有进入 OVS 的以太网广播数据包\novs-ofctl add-flow ovs-switch \ntable=0, dl_src=01:00:00:00:00:00/01:00:00:00:00:00, actions=drop\n\n\n\n\n\n流表参数详解\n\n\novs-ofctl dump-flows ovs-switch\n\n\n\n\n输出\n\n\nNXST_FLOW reply (xid=0x4):\ncookie=0x0, duration=7.672s, table=0, n_packets=0, n_bytes=0, idle_age=7, priority=0 actions=NORMAL\n\n\n\n\n\n\n\n\ncookie: 不了解，官方manpage解释如下\n\n\nmanpage\nAn opaque identifier called a cookie can be used as a handle to identify a set of flows:\n\ncookie=value\n    A cookie can be associated with a flow using the add-flow, add-flows, and mod-flows commands.  value can be any 64-bit number and need not be unique among flows. If this field is omitted, a default cookie value of 0 is used.\n\ncookie=value/mask\n    When using NXM, the cookie can be used as a handle for querying, modifying, and deleting flows. value and mask may be supplied for the del-flows, mod-flows, dump-flows, and dump-aggregate commands to limit matching cookies. A 1-bit in mask indicates that the corresponding bit in cookie must match exactly, and a 0-bit wildcards that bit. A mask of -1 may be used to exactly match a cookie.\n\n    The  mod-flows  command can update the cookies of flows that match a cookie by specifying the cookie field twice (once with a mask for matching and once without to indicate the new value):\n\n    ovs-ofctl mod-flows br0 cookie=1,actions=normal\n        Change all flows\n cookies to 1 and change their actions to normal.\n\n    ovs-ofctl mod-flows br0 cookie=1/-1,cookie=2,actions=normal\n        Update cookies with a value of 1 to 2 and change their actions to normal.\n\n    The ability to match on cookies was added in Open vSwitch 1.5.0.\n\n\n\n\n\n\n\nduration: 该条目创建多久了\n\n\n\n\n\n\ntable: 该条目所属table\n\n\n\n\n\n\nn_packets: 匹配了多少个包，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的\n\n\n\n\n\n\nn_bytes: 匹配的所有包的大小总和，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的\n\n\n\n\n\n\nidle_age: 该条目多久没被匹配了，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的\n\n\n\n\n\n\npriority: 表内条目优先级，0-65535，数字越过越优先，不指定优先级则为32768，相同优先级的话，先插入的优先（dump-flows结果中靠上的优先）\n\n\n\n\n\n\nactions: 匹配之后的操作\n\n\n\n\n\n\n实验\n\n\n\n\n使用openflow转发包到多个端口\n\n\n转到任何端口的方法都是一样的，包括veth和vtep。效果等同于用linux bridge时候的bridge fdb append\n\n\n# 先清空默认条目，以免导致环路，也是为了更了解数据包\novs-ofctl del-flows br-tun\n\n# \b转到openflow端口1、2、3、4\novs-ofctl add-flow br-tun \ntable=0, dl_dst=01:00:00:00:00:00/01:00:00:00:00:00, actions=output:1,2,3,4\n\n\n\n\n\n上面的\n\n\nactions=output:1,2,3,4\n\n\n\n\n等同于(ovs-ofctl就可以看到自动翻译成如下)\n\n\nactions=output:1,output:2,output:3,output:4\n\n\n\n\n流表匹配顺序\n\n\n\n\ntable -\n flow priority\n\n\n即先从table开始，从0到254，在table里有多个openflow条目，根据优先级priority最高的优先匹配", 
            "title": "四. openflow"
        }, 
        {
            "location": "/openflow/#_1", 
            "text": "# 查看openflow端口信息\novs-ofctl show ovs-switch\n\n# 查看openflow端口编号\novs-vsctl get interface p0 ofport\n\n# 查看datapath\novs-dpctl show\n\n# 查看流表\novs-ofctl dump-flows ovs-switch", 
            "title": "查看"
        }, 
        {
            "location": "/openflow/#_2", 
            "text": "", 
            "title": "流表操作"
        }, 
        {
            "location": "/openflow/#_3", 
            "text": "每个交换机创建之后默认都有一条流表规则，用于允许所有流量通过  NXST_FLOW reply (xid=0x4):  cookie=0x0, duration=1588.919s, table=0, n_packets=50, n_bytes=3260, idle_age=0, priority=0 actions=NORMAL  加亮这条就是默认的流表，如果这条删掉，那么当其他条目都没匹配到的时候，数据包就会被丢弃", 
            "title": "默认规则"
        }, 
        {
            "location": "/openflow/#_4", 
            "text": "# 屏蔽所有进入 OVS 的以太网广播数据包\novs-ofctl add-flow ovs-switch  table=0, dl_src=01:00:00:00:00:00/01:00:00:00:00:00, actions=drop", 
            "title": "添加规则"
        }, 
        {
            "location": "/openflow/#_5", 
            "text": "ovs-ofctl dump-flows ovs-switch  输出  NXST_FLOW reply (xid=0x4):\ncookie=0x0, duration=7.672s, table=0, n_packets=0, n_bytes=0, idle_age=7, priority=0 actions=NORMAL    cookie: 不了解，官方manpage解释如下  manpage An opaque identifier called a cookie can be used as a handle to identify a set of flows:\n\ncookie=value\n    A cookie can be associated with a flow using the add-flow, add-flows, and mod-flows commands.  value can be any 64-bit number and need not be unique among flows. If this field is omitted, a default cookie value of 0 is used.\n\ncookie=value/mask\n    When using NXM, the cookie can be used as a handle for querying, modifying, and deleting flows. value and mask may be supplied for the del-flows, mod-flows, dump-flows, and dump-aggregate commands to limit matching cookies. A 1-bit in mask indicates that the corresponding bit in cookie must match exactly, and a 0-bit wildcards that bit. A mask of -1 may be used to exactly match a cookie.\n\n    The  mod-flows  command can update the cookies of flows that match a cookie by specifying the cookie field twice (once with a mask for matching and once without to indicate the new value):\n\n    ovs-ofctl mod-flows br0 cookie=1,actions=normal\n        Change all flows  cookies to 1 and change their actions to normal.\n\n    ovs-ofctl mod-flows br0 cookie=1/-1,cookie=2,actions=normal\n        Update cookies with a value of 1 to 2 and change their actions to normal.\n\n    The ability to match on cookies was added in Open vSwitch 1.5.0.    duration: 该条目创建多久了    table: 该条目所属table    n_packets: 匹配了多少个包，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的    n_bytes: 匹配的所有包的大小总和，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的    idle_age: 该条目多久没被匹配了，注意是匹配，即如果该条目有被查询过，但是没匹配上，那么数值是不会增加的    priority: 表内条目优先级，0-65535，数字越过越优先，不指定优先级则为32768，相同优先级的话，先插入的优先（dump-flows结果中靠上的优先）    actions: 匹配之后的操作", 
            "title": "流表参数详解"
        }, 
        {
            "location": "/openflow/#_6", 
            "text": "", 
            "title": "实验"
        }, 
        {
            "location": "/openflow/#openflow", 
            "text": "转到任何端口的方法都是一样的，包括veth和vtep。效果等同于用linux bridge时候的bridge fdb append  # 先清空默认条目，以免导致环路，也是为了更了解数据包\novs-ofctl del-flows br-tun\n\n# \b转到openflow端口1、2、3、4\novs-ofctl add-flow br-tun  table=0, dl_dst=01:00:00:00:00:00/01:00:00:00:00:00, actions=output:1,2,3,4   上面的  actions=output:1,2,3,4  等同于(ovs-ofctl就可以看到自动翻译成如下)  actions=output:1,output:2,output:3,output:4", 
            "title": "使用openflow转发包到多个端口"
        }, 
        {
            "location": "/openflow/#_7", 
            "text": "table -  flow priority  即先从table开始，从0到254，在table里有多个openflow条目，根据优先级priority最高的优先匹配", 
            "title": "流表匹配顺序"
        }, 
        {
            "location": "/appendix/doc/", 
            "text": "ovs\n\n\n\n\nhttp://blog.csdn.net/sqx2011/article/details/39344869\n\n\n\n\nopenflow\n\n\n\n\n\n\nhttps://www.ibm.com/developerworks/cn/cloud/library/1401_zhaoyi_openswitch/index.html\n\n\n\n\n\n\nhttp://www.rendoumi.com/open-vswitchzhong-ovs-ofctlde-xiang-xi-yong-fa/\n\n\n\n\n\n\novn\n\n\n\n\n\n\nhttp://www.sdnlab.com/18600.html\n\n\n\n\n\n\nhttp://blog.csdn.net/zhengmx100/article/details/71698641\n\n\n\n\n\n\nmanpage\n\n\n\n\novs-vsctl的options：man ovs-vswitchd.conf.db\n\n\novs-ofctl配置流表的actions：man ovs-ofctl\n\n\nopenflow流表匹配参数：man ovs-fields", 
            "title": "1. 参考资料"
        }, 
        {
            "location": "/appendix/doc/#manpage", 
            "text": "ovs-vsctl的options：man ovs-vswitchd.conf.db  ovs-ofctl配置流表的actions：man ovs-ofctl  openflow流表匹配参数：man ovs-fields", 
            "title": "manpage"
        }, 
        {
            "location": "/appendix/traffic/", 
            "text": "在ovs里，对port只有egress限速，对interface只有ingress限速\n\n\n参考：\nhttp://openvswitch.org/support/dist-docs/ovs-vswitchd.conf.db.5.html\n\n\ningress_policing_rate就是带宽入口限速，超过的丢包处理\n\n\ningress_policing_burst 在ingress_policing_rate之上的入口突发流量限制，该值最少也要等于该interface的MTU值，最好设置为ingress_policing_rate的\n=10%，建议为10%（对TCP很重要，TCP需要对丢包作出反应，而且设置为10%后tcp流量的上限才会更接近ingress_policing_rate值）", 
            "title": "2. ovs数据流量及限速"
        }, 
        {
            "location": "/appendix/nxm/", 
            "text": "点击打开", 
            "title": "3. NXM"
        }, 
        {
            "location": "/appendix/neutron/", 
            "text": "https://github.com/yeasy/openstack_understand_Neutron\n\n\npdf文档已放入本站附件中，\n点击下载\n\n\n\n\n\n\nhttp://blog.sina.com.cn/s/blog_6de3aa8a0102uy3t.html", 
            "title": "4. Neutron流表分析"
        }, 
        {
            "location": "/appendix/mac_mask/", 
            "text": "ovs官方解释\n\n\n\n\nman ovs-fields\b\n\n\nOpen vSwitch 1.8 and later support arbitrary masks for source and/or destination. Earlier versions only support masking the destination with the following masks:\n\n       01:00:00:00:00:00\n              Match  only  the  multicast  bit.  Thus,  dl_dst=01:00:00:00:00:00/01:00:00:00:00:00  matches  all  multicast  (including  broadcast)  Ethernet  packets,  and\n              dl_dst=00:00:00:00:00:00/01:00:00:00:00:00 matches all unicast Ethernet packets.\n\n       fe:ff:ff:ff:ff:ff\n              Match all bits except the multicast bit. This is probably not useful.\n\n       ff:ff:ff:ff:ff:ff\n              Exact match (equivalent to omitting the mask).\n\n       00:00:00:00:00:00\n              Wildcard all bits (equivalent to dl_dst=*).\n\n\n\n\n单播、多播、广播\n\n\n\n\n\n\n\n\n单播: 最左边第一个字节的最后一个bit为0\n\n\nxxxxxxx0:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx\n\n\n可以用\n00:00:00:00:00:00/01:00:00:00:00:00\n来表示\n\n\n\n\n\n\n多播: 最左边第一个字节的最后一个bit为1，当所有bit都为1就是广播，即多播包括广播，就像正方形属于长方形，但正方形是独特的长方形，多播就像是长方形，广播就像是正方形\n\n\nxxxxxxx1:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx\n\n\n可以用\n01:00:00:00:00:00/01:00:00:00:00:00\n来表示，但不是只能这么表示，只要掩码里为0对应到的mac可以为任何数，即也可以写成\na1:bb:cc:dd:ee:ff/01:00:00:00:00:00\n，或者\n11:1b:cc:dd:ee:ff/11:10:08:00:00:00\n，都是可以的\n\n\n\n\n\n\n广播: 所有bit均为1，因此就是\nff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff\n\n\n\n\n\n\n如果要匹配具体的mac地址，就把掩码写成\nff:ff:ff:ff:ff:ff\n即可（如果不写掩码，默认就是全f）\n\n\n注意：如果想只匹配多播，但不包含广播，没有办法通过掩码做到，只能在写条目规则时候先匹配广播，再匹配多播\n\n\n掩码匹配算法详解\n\n\n\n\n例如\n11:1b:cc:dd:ee:ff/11:10:08:00:00:00\n表示\n\n\n地址\n11:1b:cc:dd:ee:ff\n -\n 二进制为\n00010001:00011011:11001100:11011101:11101110:11111111\n\n\n掩码\n11:10:08:00:00:00\n -\n 二进制为\n00010001:00010000:00001000:00000000:00000000:00000000\n\n\n掩码中为1的，对应到地址的bit不变，掩码中为0的，对应到地址的bit可以为1也可为0，和ip/netmask的算法是类似的，因此这个例子中，可以表示的范围是：\n\n\n最小：\n00010001:00010000:00001000:00000000:00000000:00000000\n\n\n最大：\n11111111:11111111:11111111:11111111:11111111:11111111\n\n\n转换成16进制，则是：\n\n\n从\n11:10:08:00:00:00\n到\nff:ff:ff:ff:ff:ff\n\n\n\n\nWarning\n\n\n这个例子算出来的最小地址刚好和掩码一样，这只是个巧合", 
            "title": "5. MAC地址掩码"
        }, 
        {
            "location": "/appendix/mac_mask/#ovs", 
            "text": "man ovs-fields\b  Open vSwitch 1.8 and later support arbitrary masks for source and/or destination. Earlier versions only support masking the destination with the following masks:\n\n       01:00:00:00:00:00\n              Match  only  the  multicast  bit.  Thus,  dl_dst=01:00:00:00:00:00/01:00:00:00:00:00  matches  all  multicast  (including  broadcast)  Ethernet  packets,  and\n              dl_dst=00:00:00:00:00:00/01:00:00:00:00:00 matches all unicast Ethernet packets.\n\n       fe:ff:ff:ff:ff:ff\n              Match all bits except the multicast bit. This is probably not useful.\n\n       ff:ff:ff:ff:ff:ff\n              Exact match (equivalent to omitting the mask).\n\n       00:00:00:00:00:00\n              Wildcard all bits (equivalent to dl_dst=*).", 
            "title": "ovs官方解释"
        }, 
        {
            "location": "/appendix/mac_mask/#_1", 
            "text": "单播: 最左边第一个字节的最后一个bit为0  xxxxxxx0:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx  可以用 00:00:00:00:00:00/01:00:00:00:00:00 来表示    多播: 最左边第一个字节的最后一个bit为1，当所有bit都为1就是广播，即多播包括广播，就像正方形属于长方形，但正方形是独特的长方形，多播就像是长方形，广播就像是正方形  xxxxxxx1:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx:xxxxxxxx  可以用 01:00:00:00:00:00/01:00:00:00:00:00 来表示，但不是只能这么表示，只要掩码里为0对应到的mac可以为任何数，即也可以写成 a1:bb:cc:dd:ee:ff/01:00:00:00:00:00 ，或者 11:1b:cc:dd:ee:ff/11:10:08:00:00:00 ，都是可以的    广播: 所有bit均为1，因此就是 ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff    如果要匹配具体的mac地址，就把掩码写成 ff:ff:ff:ff:ff:ff 即可（如果不写掩码，默认就是全f）  注意：如果想只匹配多播，但不包含广播，没有办法通过掩码做到，只能在写条目规则时候先匹配广播，再匹配多播", 
            "title": "单播、多播、广播"
        }, 
        {
            "location": "/appendix/mac_mask/#_2", 
            "text": "例如 11:1b:cc:dd:ee:ff/11:10:08:00:00:00 表示  地址 11:1b:cc:dd:ee:ff  -  二进制为 00010001:00011011:11001100:11011101:11101110:11111111  掩码 11:10:08:00:00:00  -  二进制为 00010001:00010000:00001000:00000000:00000000:00000000  掩码中为1的，对应到地址的bit不变，掩码中为0的，对应到地址的bit可以为1也可为0，和ip/netmask的算法是类似的，因此这个例子中，可以表示的范围是：  最小： 00010001:00010000:00001000:00000000:00000000:00000000  最大： 11111111:11111111:11111111:11111111:11111111:11111111  转换成16进制，则是：  从 11:10:08:00:00:00 到 ff:ff:ff:ff:ff:ff   Warning  这个例子算出来的最小地址刚好和掩码一样，这只是个巧合", 
            "title": "掩码匹配算法详解"
        }
    ]
}